<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>画像放り込みシンプル表作成</title>
    <link rel="icon" href="favicon2.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- ★ 修正点: Font Awesomeのライブラリを追加 -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles */
        body {
            font-family: 'Noto Sans JP', 'Roboto', sans-serif;
            overflow: hidden; /* Prevent body scroll */
            margin: 0; 
        }
        .canvas-container {
            background-color: #f0f2f5;
            cursor: default;
        }
        canvas {
            background-color: #ffffff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform-origin: top left;
        }
        /* Custom scrollbar for settings panel */
        .settings-panel::-webkit-scrollbar { width: 6px; }
        .settings-panel::-webkit-scrollbar-track { background: #f1f1f1; }
        .settings-panel::-webkit-scrollbar-thumb { background: #888; border-radius: 3px; }
        .settings-panel::-webkit-scrollbar-thumb:hover { background: #555; }
        /* Hide default file input */
        input[type="file"] { display: none; }
        /* 背景ドロップエリアのスタイル */
        #background-drop-area {
            border: 2px dashed #cbd5e1;
            transition: background-color 0.2s;
        }
        #background-drop-area.dragover {
            background-color: #e2e8f0;
        }
        /* アコーディオンのスタイルを改善 */
        .accordion-header {
            background-color: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            padding: 0.5rem 0.75rem;
            transition: background-color 0.2s;
        }
        .accordion-header:hover {
            background-color: #edf2f7;
        }
        .accordion-arrow {
            transition: transform 0.2s ease-in-out;
        }
        .accordion-header.open .accordion-arrow {
            transform: rotate(90deg);
        }
        .accordion-header.open {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col">

    <header class="bg-white shadow-md p-2 flex items-center justify-between z-20">
        <h1 class="text-xl font-bold text-gray-700" data-lang-key="app-title">画像放り込みシンプル表作成</h1>
        <div class="flex items-center space-x-2">
            <!-- ★ 修正点: 全画面表示ボタンの見た目を変更 -->
            <button id="fullscreen-btn" class="p-2 rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 text-gray-600 bg-gray-200 hover:bg-gray-300 focus:ring-gray-400 w-11 h-11 flex items-center justify-center" title="全画面表示">
                <i id="fullscreen-icon" class="fas fa-expand"></i>
            </button>
            <div class="border-l h-6 border-gray-300 mx-2"></div>
            <button id="export-image-btn" class="px-4 py-2 rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 text-white bg-gray-500 hover:bg-gray-600 focus:ring-gray-400" data-lang-key="export">画像出力</button>
            <button id="help-btn" class="px-4 py-2 rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 text-white bg-gray-500 hover:bg-gray-600 focus:ring-gray-400" data-lang-key="help">操作方法</button>

            <div class="border-l h-6 border-gray-300 mx-2"></div>

            <button id="save-project-btn" class="px-4 py-2 rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 text-white bg-gray-500 hover:bg-gray-600 focus:ring-gray-400" data-lang-key="save">保存</button>
            <label for="load-project-input" class="px-4 py-2 rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 text-white bg-gray-500 hover:bg-gray-600 focus:ring-gray-400 cursor-pointer" data-lang-key="load">呼び出し</label>
            <input type="file" id="load-project-input" accept=".json">

            <div class="border-l h-6 border-gray-300 mx-2"></div>

            <button id="language-toggle-btn" class="px-4 py-2 rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 text-white bg-gray-500 hover:bg-gray-600 focus:ring-gray-400 w-24"></button>
        </div>
    </header>

    <div class="flex flex-grow overflow-hidden">
        <aside class="w-80 bg-white p-4 shadow-lg flex-shrink-0 overflow-y-auto settings-panel z-10">
            <div id="main-settings-panel">
                <h2 class="text-lg font-bold mb-4 border-b pb-2" data-lang-key="settings-title">設定</h2>
                <div class="space-y-4">
                    <div class="pt-2">
                        <button id="auto-adjust-btn" class="w-full px-4 py-2 rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 bg-indigo-500 hover:bg-indigo-600 text-white focus:ring-indigo-400" data-lang-key="auto-adjust"></button>
                    </div>
                    <div>
                        <button id="accordion-field" class="w-full flex justify-between items-center text-left font-semibold accordion-header">
                            <span data-lang-key="field-settings">フィールド設定</span>
                            <svg class="accordion-arrow w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                        </button>
                        <div id="accordion-field-content" class="hidden border border-t-0 border-gray-200 rounded-b-md p-4 space-y-4">
                            <div>
                                <label for="zoom-slider" class="block text-sm font-medium text-gray-700"><span data-lang-key="zoom-level">表示倍率</span>: <span id="zoom-level-value">100</span>%</label>
                                <input type="range" id="zoom-slider" min="10" max="200" value="100" step="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            </div>
                            <div class="flex items-center justify-between">
                                <label for="title-visible-toggle" class="text-sm font-medium text-gray-700" data-lang-key="show-title">タイトルを表示</label>
                                <input type="checkbox" id="title-visible-toggle" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                            </div>
                            <div class="flex items-center justify-between">
                                <label for="grid-visible-toggle" class="text-sm font-medium text-gray-700" data-lang-key="show-grid">グリッドを表示</label>
                                <input type="checkbox" id="grid-visible-toggle" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                            </div>
                            <div>
                                <label for="grid-size" class="block text-sm font-medium text-gray-700"><span data-lang-key="grid-width">グリッド幅</span>: <span id="grid-size-value">5</span>px</label>
                                <input type="range" id="grid-size" min="0" max="50" value="5" step="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            </div>
                            <div>
                                <h3 class="text-md font-semibold mb-2" data-lang-key="bg-settings">背景設定</h3>
                                <div id="background-drop-area" class="p-4 rounded-lg text-center text-gray-500">
                                    <span data-lang-key="bg-drop-text">ここに背景画像をドロップ</span>
                                </div>
                                <div id="background-controls" class="mt-2 space-y-2 hidden">
                                    <div>
                                        <label for="bg-opacity" class="block text-sm font-medium text-gray-700"><span data-lang-key="bg-opacity">画像透過度</span>: <span id="bg-opacity-value">1</span></label>
                                        <input type="range" id="bg-opacity" min="0" max="1" step="0.05" value="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                    </div>
                                    <div>
                                        <label for="bg-scale" class="block text-sm font-medium text-gray-700"><span data-lang-key="bg-scale">拡大率</span>: <span id="bg-scale-value">1</span></label>
                                        <input type="range" id="bg-scale" min="0.1" max="5" step="0.1" value="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700" data-lang-key="bg-pos-xy">位置（横/縦）</label>
                                        <input type="range" id="bg-pos-x" min="-1000" max="1000" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                        <input type="range" id="bg-pos-y" min="-1000" max="1000" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-2">
                                    </div>
                                    <div class="pt-2">
                                        <button class="w-full reset-settings-btn px-4 py-2 rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 bg-yellow-500 hover:bg-yellow-600 text-gray-800 focus:ring-yellow-400" data-lang-key="reset-settings" data-reset-type="field">設定をリセット</button>
                                    </div>
                                    <button id="remove-bg-btn" class="w-full mt-2 px-4 py-2 rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 text-white bg-red-500 hover:bg-red-600 focus:ring-red-400" data-lang-key="bg-remove">背景を削除</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div>
                        <button id="accordion-image" class="w-full flex justify-between items-center text-left font-semibold accordion-header">
                            <span data-lang-key="img-settings">画像設定</span>
                            <svg class="accordion-arrow w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                        </button>
                        <div id="accordion-image-content" class="hidden border border-t-0 border-gray-200 rounded-b-md p-4 space-y-4">
                            <div>
                                <label for="max-img-size" class="block text-sm font-medium text-gray-700"><span data-lang-key="max-img-size">追加する画像サイズ（リサイズ後）</span>: <span id="max-img-size-value">240</span>px</label>
                                <input type="range" id="max-img-size" min="50" max="1000" value="240" step="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            </div>
                            <div>
                                <div id="img-border-settings" class="mt-2 space-y-2">
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label for="img-border-width" class="block text-sm font-medium text-gray-700"><span data-lang-key="border-width">枠線の幅</span>: <span id="img-border-width-value">2</span>px</label>
                                            <input type="range" id="img-border-width" min="0" max="20" value="2" step="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                        </div>
                                        <div>
                                            <label for="img-border-color" class="block text-sm font-medium text-gray-700" data-lang-key="border-color">枠線の色</label>
                                            <input type="color" id="img-border-color" value="#000000" class="w-full h-8 p-1 border border-gray-300 rounded-lg">
                                        </div>
                                    </div>
                                    <div>
                                        <label for="img-border-radius" class="block text-sm font-medium text-gray-700"><span data-lang-key="corner-radius">角の丸み</span>: <span id="img-border-radius-value">8</span>px</label>
                                        <input type="range" id="img-border-radius" min="0" max="50" value="8" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                    </div>
                                </div>
                            </div>
                            <div class="pt-2">
                                <button class="w-full reset-settings-btn px-4 py-2 rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 bg-yellow-500 hover:bg-yellow-600 text-gray-800 focus:ring-yellow-400" data-lang-key="reset-settings" data-reset-type="image">設定をリセット</button>
                            </div>
                            <div class="pt-2">
                                <button id="apply-image-settings-all" class="w-full px-4 py-2 rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 bg-blue-500 hover:bg-blue-600 text-white focus:ring-blue-400" data-lang-key="apply-image-settings-to-all"></button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="title-editor-panel" class="hidden">
                 <div class="flex justify-between items-center mb-4 border-b pb-2">
                    <h2 class="text-lg font-bold" data-lang-key="title-edit-title">タイトル編集</h2>
                    <button id="close-title-editor-btn" class="px-3 py-1 text-sm rounded-md bg-gray-200 hover:bg-gray-300 transition-colors" data-lang-key="return-to-settings">設定に戻る</button>
                </div>
                <div class="space-y-3">
                    <div>
                        <label for="title-content" class="block text-sm font-medium text-gray-700" data-lang-key="text">テキスト</label>
                        <textarea id="title-content" rows="2" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></textarea>
                    </div>
                    <div>
                        <label for="title-font-family" class="block text-sm font-medium text-gray-700" data-lang-key="font-family">フォント</label>
                        <select id="title-font-family" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                            <option value="'Noto Sans JP', sans-serif">Noto Sans JP</option>
                            <option value="'Roboto', sans-serif">Roboto</option>
                            <option value="serif">Serif</option>
                            <option value="monospace">Monospace</option>
                        </select>
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="title-font-size" class="block text-sm font-medium text-gray-700" data-lang-key="font-size">サイズ</label>
                            <input type="number" id="title-font-size" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                        </div>
                        <div>
                            <label for="title-color" class="block text-sm font-medium text-gray-700" data-lang-key="text-color">文字色</label>
                            <input type="color" id="title-color" class="w-full h-8 p-1 border border-gray-300 rounded-lg">
                        </div>
                    </div>
                    <div class="flex items-center space-x-4">
                        <div class="flex items-center">
                            <input type="checkbox" id="title-bold" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
                            <label for="title-bold" class="ml-2 block text-sm text-gray-900" data-lang-key="bold">太字</label>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="title-italic" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
                            <label for="title-italic" class="ml-2 block text-sm text-gray-900" data-lang-key="italic">斜体</label>
                        </div>
                    </div>
                     <div class="border-t pt-3">
                        <h3 class="text-md font-semibold mb-2" data-lang-key="shadow">影</h3>
                        <div class="flex items-center">
                            <input type="checkbox" id="title-shadow-toggle" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
                            <label for="title-shadow-toggle" class="ml-2 block text-sm text-gray-900" data-lang-key="enable-shadow">影をつける</label>
                        </div>
                         <div id="title-shadow-settings" class="mt-2 space-y-2 hidden">
                             <input type="color" id="title-shadow-color" class="w-full h-8 p-1 border border-gray-300 rounded-lg">
                        </div>
                    </div>
                    <div class="border-t pt-3">
                        <h3 class="text-md font-semibold mb-2" data-lang-key="stroke">縁取り</h3>
                        <div class="flex items-center">
                            <input type="checkbox" id="title-stroke-toggle" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
                            <label for="title-stroke-toggle" class="ml-2 block text-sm text-gray-900" data-lang-key="enable-stroke">縁取りをつける</label>
                        </div>
                        <div id="title-stroke-settings" class="mt-2 space-y-2 hidden">
                            <input type="color" id="title-stroke-color" class="w-full h-8 p-1 border border-gray-300 rounded-lg">
                            <input type="range" id="title-stroke-width" min="1" max="10" value="1" class="w-full h-2 bg-gray-200 rounded-lg">
                        </div>
                    </div>
                </div>
            </div>

            <div id="text-editor-panel" class="hidden">
                <div class="flex justify-between items-center mb-4 border-b pb-2">
                    <h2 class="text-lg font-bold" data-lang-key="img-text-edit-title">画像内テキスト編集</h2>
                    <button id="close-text-editor-btn" class="px-3 py-1 text-sm rounded-md bg-gray-200 hover:bg-gray-300 transition-colors" data-lang-key="return-to-settings">設定に戻る</button>
                </div>
                <div class="space-y-3">
                    <div>
                        <label for="text-content" class="block text-sm font-medium text-gray-700" data-lang-key="text">テキスト</label>
                        <textarea id="text-content" rows="2" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></textarea>
                    </div>
                    <div>
                        <label for="text-font-family" class="block text-sm font-medium text-gray-700" data-lang-key="font-family">フォント</label>
                        <select id="text-font-family" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                            <option value="'Noto Sans JP', sans-serif">Noto Sans JP</option>
                            <option value="'Roboto', sans-serif">Roboto</option>
                            <option value="serif">Serif</option>
                            <option value="monospace">Monospace</option>
                        </select>
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="text-font-size" class="block text-sm font-medium text-gray-700" data-lang-key="font-size">サイズ</label>
                            <input type="number" id="text-font-size" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                        </div>
                        <div>
                            <label for="text-color" class="block text-sm font-medium text-gray-700" data-lang-key="text-color">文字色</label>
                            <input type="color" id="text-color" class="w-full h-8 p-1 border border-gray-300 rounded-lg">
                        </div>
                    </div>
                    <div class="flex items-center space-x-4">
                        <div class="flex items-center">
                            <input type="checkbox" id="text-bold" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
                            <label for="text-bold" class="ml-2 block text-sm text-gray-900" data-lang-key="bold">太字</label>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="text-italic" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
                            <label for="text-italic" class="ml-2 block text-sm text-gray-900" data-lang-key="italic">斜体</label>
                        </div>
                    </div>
                     <div class="border-t pt-3">
                        <h3 class="text-md font-semibold mb-2" data-lang-key="shadow">影</h3>
                        <div class="flex items-center">
                            <input type="checkbox" id="text-shadow-toggle" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
                            <label for="text-shadow-toggle" class="ml-2 block text-sm text-gray-900" data-lang-key="enable-shadow">影をつける</label>
                        </div>
                         <div id="text-shadow-settings" class="mt-2 space-y-2 hidden">
                             <input type="color" id="text-shadow-color" class="w-full h-8 p-1 border border-gray-300 rounded-lg">
                        </div>
                    </div>
                    <div class="border-t pt-3">
                        <h3 class="text-md font-semibold mb-2" data-lang-key="stroke">縁取り</h3>
                        <div class="flex items-center">
                            <input type="checkbox" id="text-stroke-toggle" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
                            <label for="text-stroke-toggle" class="ml-2 block text-sm text-gray-900" data-lang-key="enable-stroke">縁取りをつける</label>
                        </div>
                        <div id="text-stroke-settings" class="mt-2 space-y-2 hidden">
                            <input type="color" id="text-stroke-color" class="w-full h-8 p-1 border border-gray-300 rounded-lg">
                            <input type="range" id="text-stroke-width" min="1" max="10" value="1" class="w-full h-2 bg-gray-200 rounded-lg">
                        </div>
                    </div>
                    <div class="border-t pt-3">
                        <button id="apply-text-style-all" class="w-full px-4 py-2 rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 bg-blue-500 hover:bg-blue-600 text-white focus:ring-blue-400" data-lang-key="apply-to-all"></button>
                    </div>
                    <div class="border-t pt-3" id="text-position-reset-container">
                        <button id="reset-text-position-btn" class="w-full px-4 py-2 rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 text-white bg-gray-500 hover:bg-gray-600 focus:ring-gray-400" data-lang-key="reset-text-pos">テキスト位置を中央に戻す</button>
                    </div>
                </div>
            </div>

            <div id="help-panel" class="hidden">
                 <div class="flex justify-between items-center mb-4 border-b pb-2">
                    <h2 class="text-lg font-bold" data-lang-key="help-title"></h2>
                    <button id="close-help-btn" class="px-3 py-1 text-sm rounded-md bg-gray-200 hover:bg-gray-300 transition-colors" data-lang-key="return-to-settings"></button>
                </div>
                <div class="space-y-4 text-sm">
                    <div class="p-2 bg-gray-100 rounded">
                        <h3 class="font-bold" data-lang-key="help-title-settings"></h3>
                        <p class="mt-1" data-lang-key="help-desc-settings"></p>
                    </div>
                    <div class="p-2 bg-gray-100 rounded">
                        <h3 class="font-bold" data-lang-key="help-title-add-img"></h3>
                        <p class="mt-1" data-lang-key="help-desc-add-img"></p>
                    </div>
                    <div class="p-2 bg-gray-100 rounded">
                        <h3 class="font-bold" data-lang-key="help-title-reorder"></h3>
                        <p class="mt-1" data-lang-key="help-desc-reorder"></p>
                    </div>
                    <div class="p-2 bg-gray-100 rounded">
                        <h3 class="font-bold" data-lang-key="help-title-edit-title"></h3>
                        <p class="mt-1" data-lang-key="help-desc-edit-title"></p>
                    </div>
                    <div class="p-2 bg-gray-100 rounded">
                        <h3 class="font-bold" data-lang-key="help-title-edit-img-text"></h3>
                        <p class="mt-1" data-lang-key="help-desc-edit-img-text"></p>
                    </div>
                    <div class="p-2 bg-gray-100 rounded">
                        <h3 class="font-bold" data-lang-key="help-title-delete-img"></h3>
                        <p class="mt-1" data-lang-key="help-desc-delete-img"></p>
                    </div>
                    <div class="p-2 bg-gray-100 rounded">
                        <h3 class="font-bold" data-lang-key="help-title-save-load"></h3>
                        <p class="mt-1" data-lang-key="help-desc-save-load"></p>
                    </div>
                    <div class="p-2 bg-gray-100 rounded">
                        <h3 class="font-bold" data-lang-key="help-title-export"></h3>
                        <p class="mt-1" data-lang-key="help-desc-export"></p>
                    </div>
                     <div class="p-2 bg-gray-100 rounded">
                        <h3 class="font-bold" data-lang-key="help-title-fullscreen"></h3>
                        <p class="mt-1" data-lang-key="help-desc-fullscreen"></p>
                    </div>
                </div>
            </div>
            
            <div id="export-panel" class="hidden">
                 <div class="flex justify-between items-center mb-4 border-b pb-2">
                    <h2 class="text-lg font-bold" data-lang-key="export-title">画像出力</h2>
                    <button id="close-export-panel-btn" class="px-3 py-1 text-sm rounded-md bg-gray-200 hover:bg-gray-300 transition-colors" data-lang-key="return-to-settings">設定に戻る</button>
                </div>
                <div class="space-y-4">
                    <div>
                        <label for="export-width" class="block text-sm font-medium text-gray-700" data-lang-key="export-width">出力幅 (px)</label>
                        <input type="number" id="export-width" value="1440" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                    </div>
                    <div>
                        <label for="export-format" class="block text-sm font-medium text-gray-700" data-lang-key="export-format">フォーマット</label>
                        <select id="export-format" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                            <option value="image/png">PNG</option>
                            <option value="image/jpeg">JPEG</option>
                        </select>
                    </div>
                    <div id="transparent-bg-container" class="flex items-center justify-between border-t pt-4">
                        <label for="export-transparent-bg-toggle" class="text-sm font-medium text-gray-700" data-lang-key="export-transparent-bg"></label>
                        <input type="checkbox" id="export-transparent-bg-toggle" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" checked>
                    </div>
                    <div class="flex items-center justify-between border-t pt-4">
                        <label for="export-grid-toggle" class="text-sm font-medium text-gray-700" data-lang-key="export-include-grid">グリッドを出力に含める</label>
                        <input type="checkbox" id="export-grid-toggle" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                    </div>
                </div>
                <div class="mt-6 flex flex-col space-y-2">
                    <button id="confirm-export-btn" class="w-full px-4 py-2 rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 text-white bg-purple-500 hover:bg-purple-600 focus:ring-purple-400" data-lang-key="export-confirm">出力</button>
                </div>
            </div>

        </aside>

        <main id="canvas-container" class="flex-grow bg-gray-200 grid place-items-center p-4 canvas-container overflow-auto">
            <canvas id="main-canvas" width="1440" height="1080"></canvas>
        </main>
    </div>
    
    <div id="notification" class="fixed bottom-4 right-4 px-4 py-2 rounded-lg shadow-lg text-white transition-opacity duration-300 opacity-0"></div>

<script>
// =================================================================================
// Main Application Class
// =================================================================================
class SimpleTableApp {
    constructor() {
        this.canvasEl = document.getElementById('main-canvas');
        this.ctx = this.canvasEl.getContext('2d');
        
        this.settings = new SettingsManager(this);
        this.ui = new UIManager(this);
        this.canvasManager = new CanvasManager(this, this.canvasEl, this.ctx);
        this.projectManager = new ProjectManager(this);
        this.exportManager = new ExportManager(this);
        this.historyManager = new HistoryManager(this);

        this.state = {
            editingMode: 'none', // 'none', 'title', 'imageText'
            lastImageTextStyle: this.settings.getDefaultTextSettings(),
        };

        this.init();
    }

    init() {
        this.canvasManager.init();
        this.settings.init();
        this.ui.init();
        this.projectManager.init();
        this.exportManager.init();
        this.historyManager.init();
        
        this.canvasManager.resizeCanvas();
        window.addEventListener('resize', () => this.canvasManager.resizeCanvas());

        this.drawLoop();
        this.historyManager.saveState();
    }
    
    drawLoop() {
        this.canvasManager.draw();
        requestAnimationFrame(() => this.drawLoop());
    }

    update() {
        this.canvasManager.draw();
    }
    
    enterEditMode(mode, targetObject) {
        this.state.editingMode = mode;
        
        if (targetObject.type === 'Title') {
            this.canvasManager.selectObject(targetObject);
        } else {
            const parentImage = this.canvasManager.objects.find(obj => obj.type === 'ImageObject' && obj.text === targetObject);
            if (parentImage) {
                this.canvasManager.selectObject(parentImage);
            }
        }

        if (mode === 'title') {
            this.ui.showTitleEditor(targetObject);
        } else if (mode === 'imageText') {
            this.ui.showImageTextEditor(targetObject);
        }
        this.update();
    }

    leaveEditMode() {
        this.state.editingMode = 'none';
        this.ui.hideAllEditors();
        this.canvasManager.deselectAll();
        this.historyManager.saveState();
        this.update();
    }
}

// =================================================================================
// Canvas Manager Class
// =================================================================================
class CanvasManager {
    constructor(app, canvasEl, ctx) {
        this.app = app;
        this.canvas = canvasEl;
        this.ctx = ctx;
        this.objects = [];
        this.title = null;
        this.exportFrame = null;
        this.selectedObject = null;
        this.draggingObject = null;
        this.resizingObject = null;
        this.draggingTextObject = null;
        this.backgroundImage = null;
        this.imageCounter = 0; 
        this.zoom = 1.0;
    }

    init() {
        const frameWidth = 1440;
        const frameHeight = 1080;

        this.exportFrame = new ExportFrame({
            app: this.app,
            x: 0,
            y: 0,
            width: frameWidth,
            height: frameHeight
        });

        this.title = new Title({
            app: this.app,
            text: 'タイトル',
            x: 40,
            y: 60,
            fontSize: 40,
            fontFamily: "'Noto Sans JP', sans-serif",
            fontWeight: 'bold',
            fillStyle: '#333333'
        });
        
        this.objects.push(this.exportFrame, this.title);
        
        this.addEventListeners();
    }
    
    resizeCanvas() {
        this.app.update();
    }
    
    setZoom(level) {
        this.zoom = level;
        this.canvas.style.transform = `scale(${this.zoom})`;
        this.app.update();
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.drawBackground(this.ctx);

        if (this.app.settings.config.gridVisible) {
            this.drawGrid(this.ctx, this.canvas.width, this.canvas.height);
        }

        [...this.objects].sort((a, b) => a.zIndex - b.zIndex).forEach(obj => {
            if (obj.type === 'Title' && !this.app.settings.config.titleVisible) {
                return;
            }
            obj.draw(this.ctx);
        });
        
        if (this.selectedObject && this.selectedObject.type !== 'ExportFrame') {
            this.selectedObject.drawHandles(this.ctx);
            if (this.app.state.editingMode === 'none') {
                 this.selectedObject.drawInfo(this.ctx);
            }
        }
    }

    drawBackground(ctx) {
        if (this.backgroundImage && this.backgroundImage.image) {
            const bg = this.backgroundImage;
            const settings = this.app.settings.config.background;
            ctx.save();
            ctx.globalAlpha = settings.opacity;
            const w = bg.image.width * settings.scale;
            const h = bg.image.height * settings.scale;
            ctx.drawImage(bg.image, settings.x, settings.y, w, h);
            ctx.restore();
        }
    }

    drawGrid(ctx, width, height) {
        const gridSize = this.app.settings.config.gridSize;
        if (gridSize === 0) return;
        ctx.beginPath();
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        for (let x = 0; x < width; x += gridSize) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
        }
        for (let y = 0; y < height; y += gridSize) {
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
        }
        ctx.stroke();
    }
    
    addMultipleImages(files, startX, startY) {
        const imageLoadPromises = files.map(file => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => resolve({img, name: file.name});
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        });

        Promise.all(imageLoadPromises).then(loadedImages => {
            let currentX = startX;
            let currentY = startY;
            let rowMaxHeight = 0;
            const gap = 10;

            loadedImages.forEach(imageData => {
                const tempImageObj = new ImageObject({
                    app: this.app,
                    image: imageData.img,
                    x: 0, y: 0
                });
                
                if (currentX + tempImageObj.width > this.canvas.width) {
                    currentX = startX;
                    currentY += rowMaxHeight + gap;
                    rowMaxHeight = 0;
                }

                const newImage = new ImageObject({
                    app: this.app,
                    image: imageData.img,
                    x: currentX,
                    y: currentY,
                    filename: imageData.name,
                    creationIndex: this.imageCounter++
                });

                this.objects.push(newImage);
                
                currentX += newImage.width + gap;
                if (newImage.height > rowMaxHeight) {
                    rowMaxHeight = newImage.height;
                }
            });

            if (loadedImages.length > 0) {
                this.selectObject(this.objects[this.objects.length - 1]);
            }

            this.app.update();
            this.app.historyManager.saveState();
        }).catch(error => {
            this.app.ui.showNotification('画像の読み込みに失敗しました', 'error');
        });
    }

    setBackgroundImage(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                this.backgroundImage = { image: img, src: e.target.result };
                this.app.ui.updateBackgroundControlVisibility();
                this.app.update();
                this.app.historyManager.saveState();
            };
            img.onerror = () => this.app.ui.showNotification('背景画像の読み込みに失敗しました', 'error');
            img.src = e.target.result;
        };
        reader.onerror = () => this.app.ui.showNotification('ファイルの読み込みに失敗しました', 'error');
        reader.readAsDataURL(file);
    }

    removeBackgroundImage() {
        this.backgroundImage = null;
        this.app.ui.updateBackgroundControlVisibility();
        this.app.update();
        this.app.historyManager.saveState();
    }

    addEventListeners() {
        const container = document.getElementById('canvas-container');
        container.addEventListener('dragover', (e) => e.preventDefault());
        container.addEventListener('drop', (e) => {
            e.preventDefault();
            if (this.app.state.editingMode !== 'none') return;

            const files = Array.from(e.dataTransfer.files);
            const pos = this.getMousePos(e);

            const imageFiles = files.filter(file => file.type.startsWith('image/'));
            if (imageFiles.length > 0) {
                this.addMultipleImages(imageFiles, pos.x, pos.y);
            }
            
            const jsonFile = files.find(file => file.name.endsWith('.json'));
            if (jsonFile) {
                this.app.projectManager.loadFile(jsonFile);
            }
        });

        container.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        container.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        container.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        container.addEventListener('dblclick', (e) => this.handleDoubleClick(e));
    }
    
    getMousePos(e) {
        const canvasRect = this.canvas.getBoundingClientRect();
        return {
            x: (e.clientX - canvasRect.left) / this.zoom,
            y: (e.clientY - canvasRect.top) / this.zoom
        };
    }
    
    handleMouseDown(e) {
        const pos = this.getMousePos(e);

        const frameHandle = this.exportFrame.getHandleAt(pos.x, pos.y);
        if (frameHandle) {
            this.resizingObject = { object: this.exportFrame, handle: frameHandle };
            if (this.selectedObject !== this.exportFrame) {
                this.selectObject(this.exportFrame);
            }
            this.app.update();
            return;
        }
        if (this.exportFrame.isHit(pos.x, pos.y)) {
            this.draggingObject = this.exportFrame;
            if (this.selectedObject !== this.exportFrame) {
                this.selectObject(this.exportFrame);
            }
            this.app.update();
            return;
        }

        if (this.app.state.editingMode === 'imageText') {
            const currentTextObject = this.app.ui.editorBindings.text.currentObject;
            const parentImage = this.objects.find(obj => obj.type === 'ImageObject' && obj.text === currentTextObject);
            
            if (parentImage) {
                const relativeX = pos.x - parentImage.x;
                const relativeY = pos.y - parentImage.y;
                if (currentTextObject.isHit(relativeX, relativeY)) {
                    this.draggingTextObject = currentTextObject;
                    this.app.update();
                    return;
                }
            }
            this.app.leaveEditMode();
            return;
        } 
        
        if (this.app.state.editingMode === 'title') {
            const titleObject = this.app.canvasManager.title;
            if (!titleObject.isHit(pos.x, pos.y)) {
                this.app.leaveEditMode();
            }
            return;
        }

        const sortedObjects = [...this.objects].sort((a, b) => b.zIndex - a.zIndex);
        for (const obj of sortedObjects) {
            if (obj === this.exportFrame || typeof obj.getHandleAt !== 'function') continue;
            
            const handle = obj.getHandleAt(pos.x, pos.y);
            if (handle) {
                this.selectObject(obj);
                if (handle.type === 'resize') {
                    this.resizingObject = { object: obj, handle: handle };
                } else if (handle.type === 'delete') {
                    this.deleteObject(obj);
                }
                this.app.update();
                return;
            }
        }

        let objectFound = false;
        for (const obj of sortedObjects) {
            if (obj === this.exportFrame) continue;
            if (obj.isHit(pos.x, pos.y)) {
                if (obj !== this.selectedObject) {
                    this.selectObject(obj);
                }
                if (obj.isDraggable) {
                    this.draggingObject = obj;
                }
                objectFound = true;
                break;
            }
        }
        
        if (!objectFound) {
            this.deselectAll();
        }
        this.app.update();
    }


    handleMouseMove(e) {
        const pos = this.getMousePos(e);
        const container = document.getElementById('canvas-container');

        if (this.draggingTextObject) {
            this.draggingTextObject.move(e.movementX / this.zoom, e.movementY / this.zoom);
            this.app.update();
            return;
        }
        
        if (this.app.state.editingMode === 'imageText') {
            const currentTextObject = this.app.ui.editorBindings.text.currentObject;
            const parentImage = this.objects.find(obj => obj.type === 'ImageObject' && obj.text === currentTextObject);
            if (parentImage) {
                const relativeX = pos.x - parentImage.x;
                const relativeY = pos.y - parentImage.y;
                container.style.cursor = currentTextObject.isHit(relativeX, relativeY) ? 'move' : 'default';
            }
            return;
        }

        if (this.resizingObject) {
            this.resizingObject.object.resize(pos.x, pos.y, this.resizingObject.handle);
            this.app.update();
            return;
        }
        
        if (this.draggingObject) {
            this.draggingObject.move(e.movementX / this.zoom, e.movementY / this.zoom);
            this.app.update();
            return;
        }
        
        let cursor = 'default';

        const frameHandle = this.exportFrame.getHandleAt(pos.x, pos.y);
        if (frameHandle) {
            cursor = frameHandle.cursor;
        } else if (this.exportFrame.isHit(pos.x, pos.y)) {
            cursor = 'move';
        } else {
            const sortedObjects = [...this.objects].sort((a, b) => b.zIndex - a.zIndex);
            for (const obj of sortedObjects) {
                 if (obj === this.exportFrame || typeof obj.getHandleAt !== 'function') continue;
                 const handle = obj.getHandleAt(pos.x, pos.y);
                 if (handle) {
                     cursor = handle.cursor;
                     break;
                 }
                 if (obj.isHit(pos.x, pos.y) && obj.isDraggable) {
                     cursor = 'move';
                     break;
                 }
            }
        }
        container.style.cursor = cursor;
    }

    handleMouseUp(e) {
        const wasDraggingOrResizing = this.draggingObject || this.resizingObject || this.draggingTextObject;
        if (this.draggingTextObject) {
            this.draggingTextObject = null;
        }
        if (this.draggingObject) {
            this.draggingObject.snapToGrid();
            this.draggingObject = null;
        }
        this.resizingObject = null;
        this.app.update();

        if (wasDraggingOrResizing) {
            this.app.historyManager.saveState();
        }
    }

    handleDoubleClick(e) {
        if (this.app.state.editingMode !== 'none') return;
        const pos = this.getMousePos(e);
        for (let i = this.objects.length - 1; i >= 0; i--) {
            const obj = this.objects[i];
            if (obj.isHit(pos.x, pos.y) && obj.isEditable) {
                obj.onDoubleClick();
                break;
            }
        }
    }
    
    selectObject(obj) {
        this.deselectAll();
        this.selectedObject = obj;
        obj.isSelected = true;
        
        if (obj.type !== 'ExportFrame') {
            const maxZ = Math.max(1, ...this.objects.filter(o => o.type !== 'ExportFrame').map(o => o.zIndex));
            obj.zIndex = maxZ + 1;
        }
        this.app.update();
    }

    deselectAll() {
        this.objects.forEach(obj => obj.isSelected = false);
        this.selectedObject = null;
        this.app.update();
    }
    
    deleteObject(obj) {
        this.objects = this.objects.filter(o => o !== obj);
        this.deselectAll();
        this.app.historyManager.saveState();
    }
    
    autoAdjustLayout() {
        const images = this.objects.filter(obj => obj.type === 'ImageObject');
        if (images.length === 0) return;

        images.sort((a, b) => a.creationIndex - b.creationIndex);

        const frame = this.exportFrame;
        const gap = this.app.settings.config.gridSize;
        const padding = gap;

        let startY = frame.y + padding;
        if (this.app.settings.config.titleVisible) {
            const titleMetrics = this.title.getMetrics();
            let titleHeight = titleMetrics.actualBoundingBoxAscent + titleMetrics.actualBoundingBoxDescent;
            if (!titleHeight || isNaN(titleHeight) || titleHeight === 0) {
                 titleHeight = this.title.fontSize * 1.2;
            }
            startY = this.title.y + titleHeight / 2 + padding + gap;
        }

        let currentX = frame.x + padding;
        let currentY = startY;
        let rowMaxHeight = 0;

        images.forEach(img => {
            if (currentX + img.width > frame.x + frame.width - padding) {
                currentX = frame.x + padding;
                currentY += rowMaxHeight + gap;
                rowMaxHeight = 0;
            }

            img.x = currentX;
            img.y = currentY;

            currentX += img.width + gap;
            if (img.height > rowMaxHeight) {
                rowMaxHeight = img.height;
            }
        });

        this.app.update();
        this.app.historyManager.saveState();
    }

    async restoreState(state) {
        this.selectedObject = null;
        this.backgroundImage = null;
        if (state.backgroundImageSrc) {
            try {
                const img = await new Promise((resolve, reject) => {
                    const image = new Image();
                    image.onload = () => resolve(image);
                    image.onerror = reject;
                    image.src = state.backgroundImageSrc;
                });
                this.backgroundImage = { image: img, src: state.backgroundImageSrc };
            } catch (error) {
                console.error('Error restoring background image:', error);
                // this.app.ui.showNotification('背景画像の復元に失敗しました', 'error');
            }
        }

        this.imageCounter = 0; 
        const objectPromises = state.objects.map(objData => {
            switch(objData.type) {
                case 'Title':
                    return Promise.resolve(Title.fromJSON(objData, this.app));
                case 'ImageObject':
                    if (objData.creationIndex === undefined) {
                        objData.creationIndex = this.imageCounter++;
                    } else if (objData.creationIndex >= this.imageCounter) {
                        this.imageCounter = objData.creationIndex + 1;
                    }
                    return ImageObject.fromJSON(objData, this.app);
                case 'ExportFrame':
                    return Promise.resolve(ExportFrame.fromJSON(objData, this.app));
                default:
                    return Promise.resolve(null);
            }
        });

        try {
            const loadedObjects = await Promise.all(objectPromises);
            this.objects = loadedObjects.filter(Boolean);

            this.title = this.objects.find(o => o.type === 'Title');
            this.exportFrame = this.objects.find(o => o.type === 'ExportFrame');

            this.app.update();
            this.app.ui.updateBackgroundControlVisibility();
        } catch (error) {
            console.error('Error restoring objects:', error);
            // this.app.ui.showNotification('オブジェクトの復元に失敗しました', 'error');
        }
    }
}

// =================================================================================
// Draggable Object Base Class
// =================================================================================
class DraggableObject {
    constructor(config) {
        this.app = config.app;
        this.x = config.x || 0;
        this.y = config.y || 0;
        this.width = config.width || 100;
        this.height = config.height || 100;
        this.isSelected = false;
        this.isEditable = config.isEditable !== undefined ? config.isEditable : true;
        this.isDraggable = config.isDraggable !== undefined ? config.isDraggable : true;
        this.zIndex = config.zIndex || 1;
        this.type = 'DraggableObject';
    }

    draw(ctx) {}
    isHit(x, y) {}
    drawHandles(ctx) {}
    getHandleAt(x, y) { return null; }
    drawInfo(ctx) {}
    onDoubleClick() {}

    move(dx, dy) {
        this.x += dx;
        this.y += dy;
    }
    
    resize(newX, newY, handle) { /* To be implemented by subclasses */ }
    
    snapToGrid() {
        if (!this.isDraggable) return;
        const gridSize = this.app.settings.config.gridSize;
        if (gridSize > 0) {
            this.x = Math.round(this.x / gridSize) * gridSize;
            this.y = Math.round(this.y / gridSize) * gridSize;
        }
    }
    
    toJSON() {
        return {
            type: this.type,
            x: this.x, y: this.y,
            width: this.width, height: this.height,
            zIndex: this.zIndex,
        };
    }
}

// =================================================================================
// Image Object Class
// =================================================================================
class ImageObject extends DraggableObject {
    constructor(config) {
        super(config);
        this.type = 'ImageObject';
        this.image = config.image;
        this.filename = config.filename || '';
        this.aspectRatio = this.image ? this.image.height / this.image.width : 1;
        this.border = config.border ? { ...config.border } : { ...this.app.settings.config.imageBorder };
        this.creationIndex = config.creationIndex; 
        
        const textStyleCopy = JSON.parse(JSON.stringify(this.app.state.lastImageTextStyle));
        const initialTextConfig = config.text ? JSON.parse(JSON.stringify(config.text)) : { text: '' };
        this.text = new TextObject({
            app: this.app,
            ...textStyleCopy,
            ...initialTextConfig
        });

        this.text.x = this.width / 2;
        this.text.y = this.height / 2;

        if (this.image && !config.isRestoring) {
            this.fitToMaxSize();
        }
        this.snapToGrid();
    }

    fitToMaxSize() {
        const maxSize = this.app.settings.config.maxImageSize;
        if (this.image.width > this.image.height) {
            this.width = maxSize;
            this.height = maxSize * this.aspectRatio;
        } else {
            this.height = maxSize;
            this.width = maxSize / this.aspectRatio;
        }
    }
    
    createRoundedRectPath(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
    }

    draw(ctx) {
        ctx.save();
        
        this.createRoundedRectPath(ctx, this.x, this.y, this.width, this.height, this.border.enabled ? this.border.radius : 0);
        ctx.save();
        ctx.clip();
        ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
        ctx.restore();

        if (this.border.enabled && this.border.width > 0) {
            ctx.strokeStyle = this.border.color;
            ctx.lineWidth = this.border.width;
            ctx.stroke();
        }

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.beginPath();
        ctx.rect(0, 0, this.width, this.height);
        ctx.clip();
        this.text.draw(ctx);
        ctx.restore();

        ctx.restore();
    }
    
    resize(newX, newY, handle) {
        const newWidth = Math.max(20, newX - this.x);
        this.width = newWidth;
        this.height = this.width * this.aspectRatio;
        this.text.x = this.width / 2;
        this.text.y = this.height / 2;
    }

    isHit(x, y) {
        return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;
    }

    drawHandles(ctx) {
        const handleRadius = 7;

        const resizeHandleX = this.x + this.width;
        const resizeHandleY = this.y + this.height;
        ctx.fillStyle = 'rgba(0, 123, 255, 0.8)';
        ctx.beginPath();
        ctx.arc(resizeHandleX, resizeHandleY, handleRadius, 0, Math.PI * 2);
        ctx.fill();
        
        const deleteHandleX = this.x + this.width;
        const deleteHandleY = this.y;
        ctx.fillStyle = 'rgba(220, 38, 38, 0.9)';
        ctx.beginPath();
        ctx.arc(deleteHandleX, deleteHandleY, handleRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.save();
        ctx.font = `bold ${handleRadius * 1.8}px sans-serif`;
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('×', deleteHandleX, deleteHandleY + 1);
        ctx.restore();
    }

    getHandleAt(x, y) {
        const handleHitboxRadius = 10;

        const resizeHandleX = this.x + this.width;
        const resizeHandleY = this.y + this.height;
        if (Math.sqrt(Math.pow(x - resizeHandleX, 2) + Math.pow(y - resizeHandleY, 2)) <= handleHitboxRadius) {
            return { type: 'resize', cursor: 'nwse-resize' };
        }

        const deleteHandleX = this.x + this.width;
        const deleteHandleY = this.y;
        if (Math.sqrt(Math.pow(x - deleteHandleX, 2) + Math.pow(y - deleteHandleY, 2)) <= handleHitboxRadius) {
            return { type: 'delete', cursor: 'pointer' };
        }
        return null;
    }


    drawInfo(ctx) {
        const text = `W:${Math.round(this.width)} H:${Math.round(this.height)}`;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(this.x, this.y + this.height - 20, ctx.measureText(text).width + 10, 20);
        ctx.fillStyle = 'white';
        ctx.font = '12px sans-serif';
        ctx.fillText(text, this.x + 5, this.y + this.height - 5);
    }
    
    onDoubleClick() {
        if (!this.text.text && this.filename) {
            this.text.text = this.filename.split('.').slice(0, -1).join('.');
        }
        this.app.enterEditMode('imageText', this.text);
    }

    toJSON() {
        const data = super.toJSON();
        data.imageSrc = this.image.src;
        data.filename = this.filename;
        data.border = this.border;
        data.text = this.text.toJSON();
        data.creationIndex = this.creationIndex;
        return data;
    }

    static fromJSON(data, app) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                const config = { ...data, app, image: img, isRestoring: true };
                resolve(new ImageObject(config));
            };
            img.onerror = reject;
            img.src = data.imageSrc;
        });
    }
}

// =================================================================================
// Text Object Class
// =================================================================================
class TextObject extends DraggableObject {
    constructor(config) {
        super(config);
        this.type = 'TextObject';
        this.text = config.text || '';
        this.fontFamily = config.fontFamily || 'sans-serif';
        this.fontSize = config.fontSize || 16;
        this.fontWeight = config.fontWeight || 'normal';
        this.fontStyle = config.fontStyle || 'normal';
        this.fillStyle = config.fillStyle || '#000000';
        this.textAlign = config.textAlign || 'center';
        this.shadow = config.shadow || { enabled: false, color: '#000000' };
        this.stroke = config.stroke || { enabled: false, color: '#ffffff', width: 1 };
        this.isEditable = true;
    }

    draw(ctx) {
        if (!this.text) return;
        ctx.save();
        ctx.font = `${this.fontStyle} ${this.fontWeight} ${this.fontSize}px ${this.fontFamily}`;
        ctx.textAlign = this.textAlign;
        ctx.textBaseline = 'middle';
        
        if (this.shadow.enabled) {
            ctx.shadowColor = this.shadow.color;
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
        }

        if (this.stroke.enabled && this.stroke.width > 0) {
            ctx.strokeStyle = this.stroke.color;
            ctx.lineWidth = this.stroke.width;
            ctx.strokeText(this.text, this.x, this.y);
        }
        
        ctx.fillStyle = this.fillStyle;
        ctx.fillText(this.text, this.x, this.y);
        ctx.restore();
    }

    getMetrics() {
        const ctx = this.app.ctx;
        ctx.save();
        ctx.font = `${this.fontStyle} ${this.fontWeight} ${this.fontSize}px ${this.fontFamily}`;
        const metrics = ctx.measureText(this.text);
        ctx.restore();
        return metrics;
    }
    
    isHit(x, y) {
        if (!this.text) return false;
        
        const metrics = this.getMetrics();
        const textWidth = metrics.width;
        let textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
        if (!textHeight || isNaN(textHeight) || textHeight === 0) {
            textHeight = this.fontSize * 1.2;
        }
        
        let xStart;
        if (this.textAlign === 'center') {
            xStart = this.x - textWidth / 2;
        } else if (this.textAlign === 'right') {
            xStart = this.x - textWidth;
        } else { // left
            xStart = this.x;
        }

        const yStart = this.y - textHeight / 2;

        return x >= xStart && x <= xStart + textWidth &&
               y >= yStart && y <= yStart + textHeight;
    }

    getHandleAt(x, y) {
        return null;
    }

    drawHandles(ctx) {
        const metrics = this.getMetrics();
        const textWidth = metrics.width;
        let textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
        if (!textHeight || isNaN(textHeight) || textHeight === 0) {
            textHeight = this.fontSize * 1.2;
        }

        let xStart;
        if (this.textAlign === 'center') {
            xStart = this.x - textWidth / 2;
        } else if (this.textAlign === 'right') {
            xStart = this.x - textWidth;
        } else { // 'left'
            xStart = this.x;
        }

        const yStart = this.y - textHeight / 2;
        const padding = 8;

        ctx.save();
        ctx.strokeStyle = 'rgba(0, 123, 255, 0.7)';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 3]);
        ctx.strokeRect(
            xStart - padding, 
            yStart - padding, 
            textWidth + padding * 2, 
            textHeight + padding * 2
        );
        ctx.restore();
    }
    
    toJSON() {
        const data = super.toJSON();
        data.text = this.text;
        data.fontFamily = this.fontFamily;
        data.fontSize = this.fontSize;
        data.fontWeight = this.fontWeight;
        data.fontStyle = this.fontStyle;
        data.fillStyle = this.fillStyle;
        data.textAlign = this.textAlign;
        data.shadow = this.shadow;
        data.stroke = this.stroke;
        return data;
    }

    static fromJSON(data, app) {
        return new TextObject({ ...data, app });
    }
}

// =================================================================================
// Title Class
// =================================================================================
class Title extends TextObject {
    constructor(config) {
        super(config);
        this.type = 'Title';
        this.textAlign = config.textAlign || 'left';
    }
    
    isHit(x, y) {
        if (!this.app.settings.config.titleVisible) return false;
        return super.isHit(x,y);
    }
    
    onDoubleClick() {
        this.app.enterEditMode('title', this);
    }
    
    static fromJSON(data, app) {
        return new Title({ ...data, app });
    }
}

// =================================================================================
// Export Frame Class
// =================================================================================
class ExportFrame extends DraggableObject {
    constructor(config) {
        super({ ...config, isDraggable: true, isEditable: true, zIndex: 0 });
        this.type = 'ExportFrame';
    }

    draw(ctx) {
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 123, 255, 0.7)';
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 4]);
        ctx.strokeRect(this.x, this.y, this.width, this.height);
        ctx.restore();

        this.drawHandles(ctx);
        this.drawInfo(ctx);
    }

    isHit(x, y) {
        const margin = 10;
        const onHorizontal = (y > this.y - margin && y < this.y + margin) || (y > this.y + this.height - margin && y < this.y + this.height + margin);
        const onVertical = (x > this.x - margin && x < this.x + margin) || (x > this.x + this.width - margin && x < this.x + this.width + margin);
        
        const isOutside = x < this.x - margin || x > this.x + this.width + margin || y < this.y - margin || y > this.y + this.height + margin;
        const isInside = x > this.x + margin && x < this.x + this.width - margin && y > this.y + margin && y < this.y + this.height - margin;

        return !isOutside && !isInside;
    }
    
    resize(newX, newY, handle) {
        const minSize = 50;
        if (handle.pos === 'br') {
            const rawWidth = Math.max(minSize, newX - this.x);
            const rawHeight = Math.max(minSize, newY - this.y);
            this.width = Math.round(rawWidth / 5) * 5;
            this.height = Math.round(rawHeight / 5) * 5;
        }
    }
    
    move(dx, dy) {
        super.move(dx, dy);
        const canvas = this.app.canvasManager.canvas;
        this.x = Math.max(0, Math.min(this.x, canvas.width - this.width));
        this.y = Math.max(0, Math.min(this.y, canvas.height - this.height));
    }


    drawHandles(ctx) {
        const handleSize = 10;
        ctx.fillStyle = 'rgba(0, 123, 255, 0.8)';
        this.getHandles().forEach(h => {
             ctx.fillRect(h.x - handleSize/2, h.y - handleSize/2, handleSize, handleSize);
        });
    }
    
    getHandles() {
        return [
            { pos: 'br', x: this.x + this.width, y: this.y + this.height, cursor: 'nwse-resize' },
        ];
    }

    getHandleAt(x, y) {
        const handleSize = 12;
        for (const handle of this.getHandles()) {
            if (Math.abs(x - handle.x) < handleSize/2 && Math.abs(y - handle.y) < handleSize/2) {
                return { type: 'resize', ...handle };
            }
        }
        return null;
    }
    
    drawInfo(ctx) {
        const text = `W:${Math.round(this.width)} H:${Math.round(this.height)}`;
        const lang = this.app.settings.config.language;
        const label = this.app.ui.translations[lang]['export-area-label'] || `出力範囲:`;
        const fullText = `${label} ${text}`;
        
        const textMetrics = ctx.measureText(fullText);
        const padding = 5;
        const rectWidth = textMetrics.width + padding * 2;
        const rectHeight = 20;
        const rectX = this.x + this.width - rectWidth - padding;
        const rectY = this.y + this.height - rectHeight - padding;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
        ctx.fillStyle = 'white';
        ctx.font = '12px sans-serif';
        ctx.fillText(fullText, rectX + padding, rectY + rectHeight / 2 + 5);
    }
    
    static fromJSON(data, app) {
        return new ExportFrame({ ...data, app });
    }
}

// =================================================================================
// Settings Manager Class
// =================================================================================
class SettingsManager {
    constructor(app) {
        this.app = app;
        this.storageKey = 'simpleTableCreatorSettings_v5';
        this.config = this.loadSettings();
    }

    init() {
        this.bindUI();
        this.updateUI();
        this.applySettings();
    }

    getDefaults() {
        return {
            language: 'ja',
            titleVisible: true,
            gridVisible: true,
            gridSize: 5,
            maxImageSize: 240,
            imageBorder: {
                enabled: true,
                width: 2,
                color: '#000000',
                radius: 8
            },
            background: {
                opacity: 1,
                scale: 1,
                x: 0,
                y: 0
            }
        };
    }
    
    getDefaultTextSettings() {
        return {
            fontFamily: "'Noto Sans JP', sans-serif",
            fontSize: 16,
            fontWeight: 'normal',
            fontStyle: 'normal',
            fillStyle: '#000000',
            textAlign: 'center',
            shadow: { enabled: false, color: '#000000' },
            stroke: { enabled: false, color: '#ffffff', width: 1 },
        }
    }

    loadSettings() {
        const saved = localStorage.getItem(this.storageKey);
        const loadedConfig = saved ? { ...this.getDefaults(), ...JSON.parse(saved) } : this.getDefaults();
        loadedConfig.titleVisible = true;
        return loadedConfig;
    }

    saveSettings() {
        localStorage.setItem(this.storageKey, JSON.stringify(this.config));
    }

    applySettings() {
        this.app.ui.setLanguage(this.config.language);
        this.app.update();
    }

    bindUI() {
        const settings = [
            { id: 'title-visible-toggle', key: 'titleVisible', type: 'checkbox' },
            { id: 'grid-visible-toggle', key: 'gridVisible', type: 'checkbox' },
            { id: 'grid-size', key: 'gridSize', type: 'range' },
            { id: 'zoom-slider', key: 'zoom', type: 'range' },
            { id: 'max-img-size', key: 'maxImageSize', type: 'range' },
            { id: 'img-border-width', key: 'imageBorder.width', type: 'range' },
            { id: 'img-border-color', key: 'imageBorder.color', type: 'color' },
            { id: 'img-border-radius', key: 'imageBorder.radius', type: 'range' },
            { id: 'bg-opacity', key: 'background.opacity', type: 'range', isFloat: true },
            { id: 'bg-scale', key: 'background.scale', type: 'range', isFloat: true },
            { id: 'bg-pos-x', key: 'background.x', type: 'range' },
            { id: 'bg-pos-y', key: 'background.y', type: 'range' },
        ];

        settings.forEach(setting => {
            const el = document.getElementById(setting.id);
            if (!el) return;
            const eventType = (el.type === 'range' || el.type === 'color') ? 'input' : 'change';
            
            el.addEventListener(eventType, (e) => {
                if (setting.key === 'zoom') {
                    const zoomLevel = parseInt(e.target.value) / 100;
                    this.app.canvasManager.setZoom(zoomLevel);
                    document.getElementById('zoom-level-value').textContent = e.target.value;
                    return;
                }

                let value;
                switch(setting.type) {
                    case 'checkbox': value = e.target.checked; break;
                    case 'color': value = e.target.value; break;
                    default: value = setting.isFloat ? parseFloat(e.target.value) : parseInt(e.target.value);
                }
                
                if (setting.key === 'gridSize' || setting.key === 'maxImageSize') {
                    value = Math.round(value / 5) * 5;
                    e.target.value = value;
                }

                this.setConfigValue(setting.key, value);
                this.updateUI();
                this.saveSettings();
                this.applySettings();
            });
             el.addEventListener('change', () => this.app.historyManager.saveState());
        });

        document.querySelectorAll('.reset-settings-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const resetType = e.currentTarget.dataset.resetType;
                const defaults = this.getDefaults();
                
                if (resetType === 'field') {
                    this.config.titleVisible = defaults.titleVisible;
                    this.config.gridVisible = defaults.gridVisible;
                    this.config.gridSize = defaults.gridSize;
                    this.config.background = { ...defaults.background };
                    this.app.canvasManager.removeBackgroundImage();
                } else if (resetType === 'image') {
                    this.config.maxImageSize = defaults.maxImageSize;
                    this.config.imageBorder = { ...defaults.imageBorder };
                }

                this.updateUI();
                this.saveSettings();
                this.applySettings();
                this.app.historyManager.saveState();
            });
        });
    }

    updateUI() {
        const ids = {
            'title-visible-toggle': 'titleVisible',
            'grid-visible-toggle': 'gridVisible',
            'grid-size': 'gridSize',
            'max-img-size': 'maxImageSize',
            'img-border-width': 'imageBorder.width',
            'img-border-color': 'imageBorder.color',
            'img-border-radius': 'imageBorder.radius',
            'bg-opacity': 'background.opacity',
            'bg-scale': 'background.scale',
            'bg-pos-x': 'background.x',
            'bg-pos-y': 'background.y',
        };
        for (const id in ids) {
            const el = document.getElementById(id);
            if (!el) continue;
            const value = this.getConfigValue(ids[id]);
            if (el.type === 'checkbox') el.checked = value;
            else el.value = value;
            
            const valueEl = document.getElementById(`${id}-value`);
            if (valueEl) valueEl.textContent = value;
        }
        
        this.config.imageBorder.enabled = true;
    }

    setConfigValue(key, value) {
        const keys = key.split('.');
        let obj = this.config;
        for (let i = 0; i < keys.length - 1; i++) {
            obj = obj[keys[i]];
        }
        obj[keys[keys.length - 1]] = value;
    }

    getConfigValue(key) {
        return key.split('.').reduce((o, i) => o[i], this.config);
    }
}

// =================================================================================
// UI Manager Class
// =================================================================================
class UIManager {
    constructor(app) {
        this.app = app;
        this.panels = {
            main: document.getElementById('main-settings-panel'),
            titleEditor: document.getElementById('title-editor-panel'),
            imageTextEditor: document.getElementById('text-editor-panel'),
            help: document.getElementById('help-panel'),
            export: document.getElementById('export-panel'),
        };
        this.headerButtons = {
            export: document.getElementById('export-image-btn'),
            help: document.getElementById('help-btn'),
            lang: document.getElementById('language-toggle-btn')
        };
        this.editorBindings = {};
        this.translations = {
            ja: {
                'app-title': '画像放り込みシンプル表作成', 'save': '保存', 'load': '呼び出し', 'export': '画像出力', 'help': '操作方法',
                'settings-title': '設定', 'language': '言語', 'show-title': 'タイトルを表示', 'grid-width': 'グリッド幅', 'max-img-size': '追加する画像サイズ（リサイズ後）',
                'img-settings': '画像設定', 'enable-border': '枠線をつける', 'border-width': '枠線の幅', 'border-color': '枠線の色', 'corner-radius': '角の丸み',
                'reset-settings': '設定をリセット', 'title-edit-title': 'タイトル編集', 'img-text-edit-title': '画像内テキスト編集',
                'text': 'テキスト', 'font-size': 'サイズ', 'font-family': 'フォント', 'text-color': '文字色', 'bold': '太字', 'italic': '斜体', 'shadow': '影',
                'enable-shadow': '影をつける', 'stroke': '縁取り', 'enable-stroke': '縁取りをつける', 'reset-text-pos': 'テキスト位置を中央に戻す',
                'help-title': '操作方法', 'help-title-settings': '設定変更', 'help-desc-settings': '左の設定パネルから変更できます。<br>変更した設定はアプリを閉じても維持されます（ただし「保存」ボタンでDL推奨です）。<br>画像設定や画像内テキストを変更した場合、次に追加された画像から設定が適用されます。',
                'help-title-add-img': '画像追加', 'help-desc-add-img': 'PC上の画像ファイルを右側のフィールドにドラッグ＆ドロップします。画像は分かりやすいフォルダにまとめておきましょう。画像は右下のハンドルをドラッグしてリサイズできます。',
                'help-title-reorder': '並び替え', 'help-desc-reorder': 'フィールド上の画像とタイトルはドラッグ＆ドロップで順序を入れ替えられます。<br>また、「画像を自動で整列」ボタンを押すと、画像が追加された順番で、設定したグリッド幅を最小の間隔として自動で整列します。',
                'help-title-edit-title': 'タイトルの編集', 'help-desc-edit-title': 'タイトルテキストをダブルクリックすると、編集パネルが出てきます。',
                'help-title-edit-img-text': '画像内のテキスト編集', 'help-desc-edit-img-text': '画像をダブルクリックすると、左パネルに調整メニューが表示されます。調整後、「設定に戻る」で設定パネルに戻ります。',
                'help-title-delete-img': '画像削除', 'help-desc-delete-img': '画像にマウスを乗せると右上に表示される×ボタンで削除します。',
                'help-title-save-load': '保存と呼び出し', 'help-desc-save-load': '「保存」ボタンで現在の状態をファイル(.json)に保存（ダウンロード）します。「呼び出し」ボタンでファイルを読み込んで復元できます。',
                'help-title-export': '画像出力', 'help-desc-export': '上部の「画像出力」ボタンで、現在のフィールドを一枚の画像として保存（ダウンロード）できます。',
                'help-title-fullscreen': '全画面表示', 'help-desc-fullscreen': 'ヘッダー右上のボタンから全画面表示の切り替えができます。OBSのウィンドウキャプチャで利用する際は、この機能でブラウザのUI（URLバーなど）を非表示にすることを推奨します。',
                'export-title': '画像出力', 'export-width': '出力幅 (px)',
                'export-format': 'フォーマット', 'cancel': 'キャンセル', 'export-confirm': '出力', 'export-area-label': '出力範囲:', 'confirm-reset': 'このセクションの設定を初期状態に戻しますか？',
                'show-grid': 'グリッドを表示', 'field-settings': 'フィールド設定', 'bg-settings': '背景設定', 'bg-drop-text': 'ここに背景画像をドロップ', 'bg-opacity': '画像透過度', 'bg-scale': '拡大率', 'bg-pos-xy': '位置（横/縦）',
                'export-include-grid': 'グリッドを出力に含める', 'bg-remove': '背景を削除', 'return-to-settings': '設定に戻る',
                'apply-to-all': '全てのテキストに変更を適用',
                'apply-image-settings-to-all': '全ての画像に変更を適用',
                'text-placeholder': 'テキスト',
                'auto-adjust': '画像を自動で整列',
                'export-transparent-bg': '背景を透過する (PNGのみ)',
                'zoom-level': '表示倍率',
                // ★ 修正点: 翻訳キーを追加
                'fullscreen': '全画面表示',
                'fullscreen-exit': '全画面表示を解除'
            },
            en: {
                'app-title': 'Simple Image Table Creator', 'save': 'Save', 'load': 'Load', 'export': 'Export Image', 'help': 'Help',
                'settings-title': 'Settings', 'language': 'Language', 'show-title': 'Show Title', 'grid-width': 'Grid Width', 'max-img-size': 'Added Image Size (Resized)',
                'img-settings': 'Image Settings', 'enable-border': 'Enable Border', 'border-width': 'Border Width', 'border-color': 'Border Color', 'corner-radius': 'Corner Radius',
                'reset-settings': 'Reset Settings', 'title-edit-title': 'Edit Title', 'img-text-edit-title': 'Edit Image Text',
                'text': 'Text', 'font-size': 'Size', 'font-family': 'Font', 'text-color': 'Color', 'bold': 'Bold', 'italic': 'Italic', 'shadow': 'Shadow',
                'enable-shadow': 'Enable Shadow', 'stroke': 'Stroke', 'enable-stroke': 'Enable Stroke', 'reset-text-pos': 'Reset Text Position',
                'help-title': 'How to Use', 'help-title-settings': 'Changing Settings', 'help-desc-settings': 'You can change settings from the left panel.<br>Changed settings are maintained even if you close the app (however, downloading with the "Save" button is recommended).<br>If you change image settings or image text, the settings will be applied to newly added images.',
                'help-title-add-img': 'Adding Images', 'help-desc-add-img': 'Drag and drop image files from your PC onto the right field. It\'s a good idea to keep images in an easy-to-find folder. Images can be resized by dragging the bottom-right handle.',
                'help-title-reorder': 'Reordering', 'help-desc-reorder': 'Images and titles on the field can be reordered by drag and drop.<br>Also, click the "Auto Align" button to automatically align images in the order they were added, using the current grid size as the minimum spacing.',
                'help-title-edit-title': 'Editing the Title', 'help-desc-edit-title': 'Double-click the title text to open the editing panel.',
                'help-title-edit-img-text': 'Editing Text in Images', 'help-desc-edit-img-text': 'Double-click an image to display the adjustment menu in the left panel. After adjusting, return to the settings panel with "Return to Settings".',
                'help-title-delete-img': 'Deleting Images', 'help-desc-delete-img': 'Delete an image by clicking the "x" button that appears in the upper right corner when you mouse over it.',
                'help-title-save-load': 'Saving and Loading', 'help-desc-save-load': 'Save the current state to a file (.json) with the "Save" button (download). You can restore it by loading the file with the "Load" button.',
                'help-title-export': 'Exporting Images', 'help-desc-export': 'You can save (download) the current field as a single image with the "Export Image" button at the top.',
                 'help-title-fullscreen': 'Fullscreen Display', 'help-desc-fullscreen': 'You can toggle fullscreen display from the button in the upper right corner of the header. When using with OBS window capture, it is recommended to use this feature to hide the browser UI (URL bar, etc.).',
                'export-title': 'Export Image', 'export-width': 'Export Width (px)',
                'export-format': 'Format', 'cancel': 'Cancel', 'export-confirm': 'Export', 'export-area-label': 'Export Area:',
                'show-grid': 'Show Grid', 'field-settings': 'Field Settings', 'bg-settings': 'Background Settings', 'bg-drop-text': 'Drop background image here', 'bg-opacity': 'Image Opacity', 'bg-scale': 'Scale', 'bg-pos-xy': 'Position (X/Y)',
                'export-include-grid': 'Include grid in export', 'bg-remove': 'Remove Background', 'return-to-settings': 'Return to Settings',
                'apply-to-all': 'Apply to All Texts',
                'apply-image-settings-to-all': 'Apply to All Images',
                'text-placeholder': 'Text',
                'auto-adjust': 'Auto Align Images',
                'export-transparent-bg': 'Transparent Background (PNG only)',
                'zoom-level': 'Zoom Level',
                 // ★ 修正点: 翻訳キーを追加
                'fullscreen': 'Enter Fullscreen',
                'fullscreen-exit': 'Exit Fullscreen'
            }
        };
    }

    init() {
        this.headerButtons.export.addEventListener('click', () => this.showPanel('export'));
        this.headerButtons.help.addEventListener('click', () => this.showPanel('help'));
        this.headerButtons.lang.addEventListener('click', () => {
            const newLang = this.app.settings.config.language === 'ja' ? 'en' : 'ja';
            this.app.settings.config.language = newLang;
            this.app.settings.saveSettings();
            this.app.settings.applySettings();
        });

        document.getElementById('close-help-btn').addEventListener('click', () => this.showPanel('main'));
        document.getElementById('close-title-editor-btn').addEventListener('click', () => this.app.leaveEditMode());
        document.getElementById('close-text-editor-btn').addEventListener('click', () => this.app.leaveEditMode());
        document.getElementById('close-export-panel-btn').addEventListener('click', () => this.showPanel('main'));
        
        document.getElementById('auto-adjust-btn').addEventListener('click', () => {
            this.app.canvasManager.autoAdjustLayout();
        });

        // ★ 修正点: 全画面表示ボタンのイベントリスナー
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    alert(`全画面表示に失敗しました: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });
        document.addEventListener('fullscreenchange', () => {
            const isFullscreen = !!document.fullscreenElement;
            const icon = document.getElementById('fullscreen-icon');
            if (isFullscreen) {
                icon.classList.remove('fa-expand');
                icon.classList.add('fa-compress');
            } else {
                icon.classList.remove('fa-compress');
                icon.classList.add('fa-expand');
            }
            this.setLanguage(this.app.settings.config.language);
        });


        this.bindEditor('title', (obj, prop, val) => { obj[prop] = val; });
        this.bindEditor('text', (target, prop, val) => {
            target[prop] = val;
            const currentTextObject = this.editorBindings.text.currentObject;
            if (currentTextObject) {
                this.app.state.lastImageTextStyle = currentTextObject.toJSON();
            }
        });

        const dropArea = document.getElementById('background-drop-area');
        dropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropArea.classList.add('dragover');
        });
        dropArea.addEventListener('dragleave', () => {
            dropArea.classList.remove('dragover');
        });
        dropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            dropArea.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                const file = e.dataTransfer.files[0];
                if (file.type.startsWith('image/')) {
                    this.app.canvasManager.setBackgroundImage(file);
                }
            }
        });

        document.querySelectorAll('.accordion-header').forEach(header => {
            header.addEventListener('click', () => {
                const content = header.nextElementSibling;
                header.classList.toggle('open');
                content.classList.toggle('hidden');
            });
        });

        document.getElementById('remove-bg-btn').addEventListener('click', () => {
            this.app.canvasManager.removeBackgroundImage();
        });

        document.getElementById('apply-image-settings-all').addEventListener('click', () => {
            this.applyImageSettingsToAll();
        });
        document.getElementById('apply-text-style-all').addEventListener('click', () => {
            this.applyTextStyleToAll();
        });
        
        const exportFormatSelect = document.getElementById('export-format');
        const transparentBgContainer = document.getElementById('transparent-bg-container');
        const toggleTransparentBgOption = () => {
            if (exportFormatSelect.value === 'image/png') {
                transparentBgContainer.classList.remove('hidden');
            } else {
                transparentBgContainer.classList.add('hidden');
            }
        };
        exportFormatSelect.addEventListener('change', toggleTransparentBgOption);
        toggleTransparentBgOption(); 
    }

    setLanguage(lang) {
        document.querySelectorAll('[data-lang-key]').forEach(el => {
            const key = el.dataset.langKey;
            if (this.translations[lang] && this.translations[lang][key]) {
                el.innerHTML = this.translations[lang][key];
            }
        });
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        if (fullscreenBtn) {
            const isFullscreen = !!document.fullscreenElement;
            fullscreenBtn.title = isFullscreen ? this.translations[lang]['fullscreen-exit'] : this.translations[lang]['fullscreen'];
        }
        this.headerButtons.lang.textContent = lang === 'ja' ? 'English' : '日本語';
    }
    
    showPanel(panelName) {
        Object.values(this.panels).forEach(p => p.classList.add('hidden'));
        this.panels[panelName].classList.remove('hidden');
        this.updateHeaderButtons(panelName);
    }

    updateHeaderButtons(activePanelName) {
        const exportBtn = this.headerButtons.export;
        const helpBtn = this.headerButtons.help;

        exportBtn.classList.remove('bg-purple-500', 'hover:bg-purple-600', 'focus:ring-purple-400');
        exportBtn.classList.add('bg-gray-500', 'hover:bg-gray-600', 'focus:ring-gray-400');
        helpBtn.classList.remove('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-400');
        helpBtn.classList.add('bg-gray-500', 'hover:bg-gray-600', 'focus:ring-gray-400');

        if (activePanelName === 'export') {
            exportBtn.classList.remove('bg-gray-500', 'hover:bg-gray-600', 'focus:ring-gray-400');
            exportBtn.classList.add('bg-purple-500', 'hover:bg-purple-600', 'focus:ring-purple-400');
        } else if (activePanelName === 'help') {
            helpBtn.classList.remove('bg-gray-500', 'hover:bg-gray-600', 'focus:ring-gray-400');
            helpBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-400');
        }
    }

    updateBackgroundControlVisibility() {
        const controls = document.getElementById('background-controls');
        if (this.app.canvasManager.backgroundImage) {
            controls.classList.remove('hidden');
        } else {
            controls.classList.add('hidden');
        }
    }

    showNotification(message, type = 'success') {
        const notification = document.getElementById('notification');
        notification.textContent = message;
        notification.classList.remove('opacity-0', 'bg-green-500', 'bg-red-500');
        
        if (type === 'success') {
            notification.classList.add('bg-green-500');
        } else {
            notification.classList.add('bg-red-500');
        }

        notification.classList.remove('opacity-0');

        setTimeout(() => {
            notification.classList.add('opacity-0');
        }, 3000);
    }

    hideAllEditors() {
        this.showPanel('main');
    }

    showTitleEditor(textObject) {
        this.showPanel('titleEditor');
        this.editorBindings.title.currentObject = textObject;
        this.populateEditor('title', textObject);
    }
    
    showImageTextEditor(textObject) {
        this.showPanel('imageTextEditor');
        this.editorBindings.text.currentObject = textObject;
        this.populateEditor('text', textObject);
    }

    populateEditor(prefix, textObject) {
        const contentEl = document.getElementById(`${prefix}-content`);
        contentEl.value = textObject.text;

        if (prefix === 'text') {
            const lang = this.app.settings.config.language;
            const placeholderText = this.translations[lang]['text-placeholder'] || 'テキスト';
            contentEl.placeholder = placeholderText;
        }

        document.getElementById(`${prefix}-font-size`).value = textObject.fontSize;
        document.getElementById(`${prefix}-font-family`).value = textObject.fontFamily;
        document.getElementById(`${prefix}-color`).value = textObject.fillStyle;
        document.getElementById(`${prefix}-bold`).checked = textObject.fontWeight === 'bold';
        document.getElementById(`${prefix}-italic`).checked = textObject.fontStyle === 'italic';
        
        document.getElementById(`${prefix}-shadow-toggle`).checked = textObject.shadow.enabled;
        document.getElementById(`${prefix}-shadow-color`).value = textObject.shadow.color;
        document.getElementById(`${prefix}-shadow-settings`).style.display = textObject.shadow.enabled ? 'block' : 'none';

        document.getElementById(`${prefix}-stroke-toggle`).checked = textObject.stroke.enabled;
        document.getElementById(`${prefix}-stroke-color`).value = textObject.stroke.color;
        document.getElementById(`${prefix}-stroke-width`).value = textObject.stroke.width;
        document.getElementById(`${prefix}-stroke-settings`).style.display = textObject.stroke.enabled ? 'block' : 'none';
    }

    bindEditor(prefix, onUpdate) {
        const bindings = {
            'content': (obj, val) => onUpdate(obj, 'text', val),
            'font-size': (obj, val) => onUpdate(obj, 'fontSize', parseInt(val) || 16),
            'font-family': (obj, val) => onUpdate(obj, 'fontFamily', val),
            'color': (obj, val) => onUpdate(obj, 'fillStyle', val),
            'bold': (obj, val) => onUpdate(obj, 'fontWeight', val ? 'bold' : 'normal'),
            'italic': (obj, val) => onUpdate(obj, 'fontStyle', val ? 'italic' : 'normal'),
            'shadow-toggle': (obj, val) => onUpdate(obj.shadow, 'enabled', val),
            'shadow-color': (obj, val) => onUpdate(obj.shadow, 'color', val),
            'stroke-toggle': (obj, val) => onUpdate(obj.stroke, 'enabled', val),
            'stroke-color': (obj, val) => onUpdate(obj.stroke, 'color', val),
            'stroke-width': (obj, val) => onUpdate(obj.stroke, 'width', parseInt(val)),
        };

        this.editorBindings[prefix] = { currentObject: null };

        for (const idSuffix in bindings) {
            const el = document.getElementById(`${prefix}-${idSuffix}`);
            if (!el) continue;
            const eventType = (el.type === 'checkbox' || el.tagName === 'SELECT' || el.type === 'color') ? 'change' : 'input';
            
            el.addEventListener(eventType, (e) => {
                const obj = this.editorBindings[prefix].currentObject;
                if (!obj) return;
                const value = (el.type === 'checkbox') ? e.target.checked : e.target.value;
                bindings[idSuffix](obj, value);
                this.app.update();
            });
            
            if (el.type === 'range' || el.type === 'color') {
                 el.addEventListener('change', () => this.app.historyManager.saveState());
            } else {
                 el.addEventListener('input', () => this.app.historyManager.saveState());
            }
        }
        
        document.getElementById(`${prefix}-shadow-toggle`).addEventListener('change', (e) => {
            document.getElementById(`${prefix}-shadow-settings`).style.display = e.target.checked ? 'block' : 'none';
        });
        document.getElementById(`${prefix}-stroke-toggle`).addEventListener('change', (e) => {
            document.getElementById(`${prefix}-stroke-settings`).style.display = e.target.checked ? 'block' : 'none';
        });
        
        if (prefix === 'text') {
            document.getElementById('reset-text-position-btn').addEventListener('click', () => {
                const obj = this.editorBindings.text.currentObject;
                if (obj && obj.type === 'TextObject') {
                    const parent = this.app.canvasManager.objects.find(p => p.text === obj);
                    if(parent) {
                        obj.x = parent.width / 2;
                        obj.y = parent.height / 2;
                        this.app.update();
                        this.app.historyManager.saveState();
                    }
                }
            });
        }
    }

    applyImageSettingsToAll() {
        const imageSettings = this.app.settings.config.imageBorder;
        this.app.canvasManager.objects.forEach(obj => {
            if (obj.type === 'ImageObject') {
                obj.border = { ...imageSettings };
                obj.fitToMaxSize(); 
            }
        });
        this.app.update();
        this.app.historyManager.saveState();
    }

    applyTextStyleToAll() {
        const currentStyleObject = this.editorBindings.text.currentObject;
        if (!currentStyleObject) return;

        const styleToApply = currentStyleObject.toJSON();
        delete styleToApply.x;
        delete styleToApply.y;
        delete styleToApply.width;
        delete styleToApply.height;
        delete styleToApply.zIndex;
        delete styleToApply.type;
        delete styleToApply.text;


        this.app.canvasManager.objects.forEach(obj => {
            if (obj.type === 'ImageObject' && obj.text) {
                Object.assign(obj.text, styleToApply);
            }
        });
        this.app.update();
        this.app.historyManager.saveState();
    }
}

// =================================================================================
// Project Manager Class
// =================================================================================
class ProjectManager {
    constructor(app) {
        this.app = app;
    }

    init() {
        document.getElementById('save-project-btn').addEventListener('click', () => this.save());
        document.getElementById('load-project-input').addEventListener('change', (e) => this.load(e.target.files[0]));
    }

    save() {
        const projectData = {
            version: 5,
            settings: this.app.settings.config,
            objects: this.app.canvasManager.objects.map(obj => obj.toJSON()),
            lastImageTextStyle: this.app.state.lastImageTextStyle,
            backgroundImageSrc: this.app.canvasManager.backgroundImage ? this.app.canvasManager.backgroundImage.src : null
        };
        
        const dataStr = JSON.stringify(projectData, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'project-v5.json';
        a.click();
        URL.revokeObjectURL(url);
        this.app.ui.showNotification('プロジェクトを保存しました');
    }

    async loadFile(file) {
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const projectData = JSON.parse(e.target.result);
                if (!projectData.version || projectData.version < 5) {
                    this.app.ui.showNotification('古いバージョンのファイルです', 'error');
                    return;
                }
                
                this.app.settings.config = projectData.settings;
                this.app.settings.updateUI();
                this.app.settings.saveSettings();
                
                if(projectData.lastImageTextStyle) {
                    this.app.state.lastImageTextStyle = projectData.lastImageTextStyle;
                }
                
                await this.app.canvasManager.restoreState(projectData);
                
                this.app.settings.applySettings();
                this.app.ui.showNotification('プロジェクトを読み込みました');
                this.app.historyManager.clear();
                this.app.historyManager.saveState();
            } catch (error) {
                console.error("プロジェクトファイルの読み込みに失敗しました:", error);
                this.app.ui.showNotification('無効なプロジェクトファイルです', 'error');
            }
        };
        reader.onerror = () => this.app.ui.showNotification('ファイルの読み込みに失敗しました', 'error');
        reader.readAsText(file);
    }
    
    async load(file) {
        this.loadFile(file);
        document.getElementById('load-project-input').value = '';
    }
}

// =================================================================================
// Export Manager Class
// =================================================================================
class ExportManager {
    constructor(app) {
        this.app = app;
    }

    init() {
        document.getElementById('confirm-export-btn').addEventListener('click', () => this.exportImage());
    }
    
    exportImage() {
        const frame = this.app.canvasManager.exportFrame;
        const exportWidth = parseInt(document.getElementById('export-width').value);
        const format = document.getElementById('export-format').value;
        const includeGrid = document.getElementById('export-grid-toggle').checked;
        const transparentBg = document.getElementById('export-transparent-bg-toggle').checked;

        const scale = exportWidth / frame.width;
        const exportHeight = frame.height * scale;

        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = exportWidth;
        exportCanvas.height = exportHeight;
        const exportCtx = exportCanvas.getContext('2d');
        
        if (format !== 'image/png' || !transparentBg) {
            exportCtx.fillStyle = '#ffffff';
            exportCtx.fillRect(0, 0, exportWidth, exportHeight);
        }

        exportCtx.save();
        exportCtx.scale(scale, scale);
        
        const canvasManager = this.app.canvasManager;

        exportCtx.save();
        exportCtx.translate(-frame.x, -frame.y);
        canvasManager.drawBackground(exportCtx);
        if (includeGrid) {
            canvasManager.drawGrid(exportCtx, canvasManager.canvas.width, canvasManager.canvas.height);
        }
        exportCtx.restore();


        exportCtx.beginPath();
        exportCtx.rect(0, 0, frame.width, frame.height);
        exportCtx.clip();
        
        exportCtx.translate(-frame.x, -frame.y);


        const objectsToDraw = canvasManager.objects.filter(obj => {
            return obj !== frame;
        });

        [...objectsToDraw].sort((a, b) => a.zIndex - b.zIndex).forEach(obj => {
             if (obj.type === 'Title' && !this.app.settings.config.titleVisible) {
                 return;
            }
            obj.draw(exportCtx);
        });

        exportCtx.restore();

        const dataUrl = exportCanvas.toDataURL(format, 0.9);
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = `export.${format.split('/')[1]}`;
        a.click();
        
        this.app.ui.showPanel('main');
    }
}

// =================================================================================
// History Manager Class
// =================================================================================
class HistoryManager {
    constructor(app) {
        this.app = app;
        this.history = [];
        this.redoStack = [];
        this.maxHistory = 30;
        this.isUndoingOrRedoing = false;
    }

    init() {
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') {
                    e.preventDefault();
                    this.undo();
                } else if (e.key === 'y' || (e.shiftKey && e.key === 'z')) {
                    e.preventDefault();
                    this.redo();
                }
            }
        });
    }

    saveState() {
        if (this.isUndoingOrRedoing) return;

        this.redoStack = []; 

        const canvasManager = this.app.canvasManager;
        const state = {
            objects: canvasManager.objects.map(obj => obj.toJSON()),
            backgroundImageSrc: canvasManager.backgroundImage ? canvasManager.backgroundImage.src : null,
            settings: JSON.parse(JSON.stringify(this.app.settings.config))
        };

        const stateString = JSON.stringify(state);
        this.history.push(stateString);

        if (this.history.length > this.maxHistory) {
            this.history.shift();
        }
    }

    async undo() {
        if (this.history.length < 2) return;

        this.isUndoingOrRedoing = true;
        const currentState = this.history.pop();
        this.redoStack.push(currentState);

        const lastStateString = this.history[this.history.length - 1];
        const state = JSON.parse(lastStateString);
        
        this.app.settings.config = state.settings;
        await this.app.canvasManager.restoreState(state);
        
        this.app.settings.updateUI();
        this.app.settings.applySettings();

        this.isUndoingOrRedoing = false;
    }

    async redo() {
        if (this.redoStack.length === 0) return;

        this.isUndoingOrRedoing = true;
        const nextStateString = this.redoStack.pop();
        this.history.push(nextStateString);

        const state = JSON.parse(nextStateString);

        this.app.settings.config = state.settings;
        await this.app.canvasManager.restoreState(state);

        this.app.settings.updateUI();
        this.app.settings.applySettings();

        this.isUndoingOrRedoing = false;
    }
    
    clear() {
        this.history = [];
        this.redoStack = [];
    }
}


// =================================================================================
// Application Entry Point
// =================================================================================
window.addEventListener('load', () => {
    new SimpleTableApp();
});

</script>
</body>
</html>

